# ==============================================================================
# Political Sphere — Composite Action: PS Task Runner
# License: Proprietary
# ==============================================================================
# ps_header_v: 6
#
# ─────────────────────────────────────────────────────────────────────────────
# IDENTITY
# ─────────────────────────────────────────────────────────────────────────────
# meta:
#   file_id: .github/actions/ps-task/ps-run/action.yml
#   file_type: action
#   language: yaml
#   version: 1.0.0
#   status: active
#   classification: internal
#   owner: political-sphere
#   last_editor: codex
#
# ─────────────────────────────────────────────────────────────────────────────
# LIFECYCLE & CHANGE CONTROL
# ─────────────────────────────────────────────────────────────────────────────
#   lifecycle:
#     created: 2025-12-28
#     last_updated: 2025-12-28
#     last_updated_mode: manual
#     review_cycle: 6 months
#     change_control: lightweight
#
# ─────────────────────────────────────────────────────────────────────────────
# CONTEXT
# ─────────────────────────────────────────────────────────────────────────────
# context:
#   parent_system: CI/CD Platform
#   initiative: Hardened CI
#
# ─────────────────────────────────────────────────────────────────────────────
# GOVERNANCE
# ─────────────────────────────────────────────────────────────────────────────
# governance:
#   intent: Provide the PS Task Runner composite action to Canonical task runner with
#     uniform logs and report outputs.
#   guarantees:
#     - Defines inputs and outputs for consistent downstream usage.
#     - Executes the composite steps declared in this action.
#     - Uses pinned external actions when referenced.
#   prohibitions:
#     - Does not grant permissions beyond the invoking workflow.
#     - Does not assume network access beyond runner policy.
#
# ─────────────────────────────────────────────────────────────────────────────
# INTERFACES
# ─────────────────────────────────────────────────────────────────────────────
# interfaces:
#   inputs: [id, title, description, script, working_directory, require_files,
#     artifact_paths, continue_on_error, env_kv, args, allow_args, strict_artifacts]
#   outputs: [status, log_path, report_path, duration_ms, exit_code, enabled]
#   exit_codes: [0=success, 1=failure]
#
# ─────────────────────────────────────────────────────────────────────────────
# EXECUTION
# ─────────────────────────────────────────────────────────────────────────────
# execution:
#   invocation: Used as a composite action step in GitHub Actions workflows.
#   example_invocation: >-
#     uses: ./.github/actions/ps-task/ps-run
#   model: deterministic
#   idempotency: not guaranteed
#
# ─────────────────────────────────────────────────────────────────────────────
# DEPENDENCIES
# ─────────────────────────────────────────────────────────────────────────────
# dependencies:
#   internal: [tools/scripts/workflows/ci/emit-report.py,
#     tools/scripts/core/string.sh,
#     tools/scripts/core/path-validation.sh,
#     tools/scripts/core/validation.sh]
#   external: [bash]
#
# ─────────────────────────────────────────────────────────────────────────────
# SECURITY & POLICY
# ─────────────────────────────────────────────────────────────────────────────
# security:
#   permissions: [none]
#   secrets: [none]
#   network: restricted; depends on runner policy
#   policy_enforcement: [configs/ci/policies/allowed-actions.yml,
#     configs/ci/policies/action-pinning.yml,
#     configs/ci/policies/inline-bash.yml,
#     configs/ci/policies/section-headers.yml]
#
# ─────────────────────────────────────────────────────────────────────────────
# OPERATIONS
# ─────────────────────────────────────────────────────────────────────────────
# ops:
#   failure_modes: Step failures or validation errors surface as non-zero exits.
#   observability: Step logs are emitted in the GitHub Actions job output.
#   performance: Seconds to minutes depending on repo size and workload.
#
# ─────────────────────────────────────────────────────────────────────────────
# RISKS
# ─────────────────────────────────────────────────────────────────────────────
# risks:
#   assumptions:
#     - Inputs are provided as documented.
#     - Runner has required tooling for declared steps.
#   known_risks:
#     - Network or platform outages can interrupt execution.
#
# ─────────────────────────────────────────────────────────────────────────────
# RELATED
# ─────────────────────────────────────────────────────────────────────────────
# related:
#   references:
#     - .github/actions/ps-task/ps-run/README.md
#     - tools/scripts/workflows/ci/emit-report.py
#     - tools/scripts/core/string.sh
#     - tools/scripts/core/path-validation.sh
#     - tools/scripts/core/validation.sh
#
# ==============================================================================

name: "PS Task Runner"
description: "Canonical task runner with uniform logs and report outputs"

inputs:
  id:
    description: "Task identifier (machine-readable, used for logs/reports)"
    required: true

  title:
    description: "Human-readable task title"
    required: true

  description:
    description: "Task description"
    required: false
    default: ""

  script:
    description: "Script path to execute (repo-relative)"
    required: true

  working_directory:
    description: "Working directory to run from (repo-relative)"
    required: false
    default: "."

  require_files:
    description: "Newline-separated list of required files (repo-relative)"
    required: false
    default: ""

  artifact_paths:
    description: "Newline-separated list of expected output paths/globs (repo-relative)"
    required: false
    default: ""

  continue_on_error:
    description: "Continue on error (0|1)"
    required: false
    default: "0"

  env_kv:
    description: "Optional multiline KEY=VALUE environment pairs"
    required: false
    default: ""

  args:
    description: "Optional arguments to pass to the script (newline-separated)"
    required: false
    default: ""

  allow_args:
    description: "Allow args passthrough (0|1)"
    required: false
    default: "1"

  strict_artifacts:
    description: "Require each artifact_paths pattern to match at least one file (0|1)"
    required: false
    default: "0"

outputs:
  status:
    description: "Task status (success|failure)"
    value: ${{ steps.ps_task_run.outputs.status }}

  log_path:
    description: "Path to the task log"
    value: ${{ steps.ps_task_run.outputs.log_path }}

  report_path:
    description: "Path to the task report JSON"
    value: ${{ steps.ps_task_run.outputs.report_path }}

  duration_ms:
    description: "Task duration in milliseconds"
    value: ${{ steps.ps_task_run.outputs.duration_ms }}

  exit_code:
    description: "Exit code from the task script"
    value: ${{ steps.ps_task_run.outputs.exit_code }}

  enabled:
    description: "Optional boolean flag emitted by tasks indicating feature enabled (true|false)"
    value: ${{ steps.ps_task_run.outputs.enabled }}

runs:
  using: "composite"
  steps:
    - name: Run task (PS)
      id: ps_task_run
      shell: bash
      env:
        PS_TASK_ID: ${{ inputs.id }}
        PS_TASK_TITLE: ${{ inputs.title }}
        PS_TASK_DESC: ${{ inputs.description }}
        PS_TASK_SCRIPT: ${{ inputs.script }}
        PS_TASK_WORKDIR: ${{ inputs.working_directory }}
        PS_TASK_REQUIRE_FILES: ${{ inputs.require_files }}
        PS_TASK_ARTIFACT_PATHS: ${{ inputs.artifact_paths }}
        PS_TASK_CONTINUE_ON_ERROR: ${{ inputs.continue_on_error }}
        PS_TASK_ENV_KV: ${{ inputs.env_kv }}
        PS_TASK_ARGS: ${{ inputs.args }}
        PS_TASK_ALLOW_ARGS: ${{ inputs.allow_args }}
        PS_TASK_STRICT_ARTIFACTS: ${{ inputs.strict_artifacts }}
      run: |
        set -euo pipefail
        readonly MAX_ENV_KV_ENTRIES=100
        readonly MAX_ENV_KV_VALUE_BYTES=65536
        readonly MAX_ENV_KV_TOTAL_BYTES=262144

        now_ms() {
          # Prefer GNU date with millisecond precision; fallback to seconds*1000.
          if [[ -n "${SOURCE_DATE_EPOCH:-}" && "${SOURCE_DATE_EPOCH}" =~ ^[0-9]+$ ]]; then
            printf '%s000' "${SOURCE_DATE_EPOCH}"
            return 0
          fi
          if out=$(date +%s%3N 2>/dev/null) && printf '%s' "$out" | grep -qE '^[0-9]+$'; then
            printf '%s' "$out"
          else
            printf '%s000' "$(date +%s)"
          fi
        }

        # shellcheck source=tools/scripts/core/string.sh
        . "${GITHUB_WORKSPACE}/tools/scripts/core/string.sh"
        # shellcheck source=tools/scripts/core/path-validation.sh
        . "${GITHUB_WORKSPACE}/tools/scripts/core/path-validation.sh"
        # shellcheck source=tools/scripts/core/validation.sh
        . "${GITHUB_WORKSPACE}/tools/scripts/core/validation.sh"

        fail() {
          if type -t v_error >/dev/null 2>&1; then
            v_error "$*"
          else
            printf 'ERROR: %s\n' "$*" >&2
          fi
          exit 1
        }

        check_under_root() {
          local target="$1"
          local resolved
          resolved="$(resolve_abs_path "${target}")" || {
            fail "path resolver missing for security check: ${target}"
          }
          case "${resolved}" in
            "${repo_root}"|${repo_root}/*) return 0 ;;
            *) fail "path escape detected: ${target} resolves outside workspace" ;;
          esac
        }

        # Security logging helper: sanitize and timestamp events
        log_security_event() {
          local level="$1"; shift
          local msg="$*"
          msg="$(printf '%s' "${msg}" | tr -d '\r\n' | tr -c '[:print:]\t' ' ')"
          local ts
          if [[ -n "${SOURCE_DATE_EPOCH:-}" && "${SOURCE_DATE_EPOCH}" =~ ^[0-9]+$ ]]; then
            if date -u -r "${SOURCE_DATE_EPOCH}" +%FT%T%z >/dev/null 2>&1; then
              ts="$(date -u -r "${SOURCE_DATE_EPOCH}" +%FT%T%z)"
            else
              ts="$(date -u -d "@${SOURCE_DATE_EPOCH}" +%FT%T%z)"
            fi
          else
            ts="$(date -u +%FT%T%z 2>/dev/null || date -u +%FT%T)"
          fi
          if [[ -n "${log_abs:-}" ]]; then
            printf '%s %s %s\n' "${ts}" "${level}" "${msg}" >> "${log_abs}"
          else
            printf '%s %s %s\n' "${ts}" "${level}" "${msg}"
          fi
        }

        # ----------------------------------------------------------------------------
        # Inputs
        # ----------------------------------------------------------------------------
        id="${PS_TASK_ID:-}"
        title="${PS_TASK_TITLE:-}"
        desc="${PS_TASK_DESC:-}"
        script_rel="${PS_TASK_SCRIPT:-}"

        workdir_input="${PS_TASK_WORKDIR:-}"
        working_directory="${workdir_input:-.}"

        continue_on_error="${PS_TASK_CONTINUE_ON_ERROR:-0}"
        env_kv="${PS_TASK_ENV_KV:-}"
        args="${PS_TASK_ARGS:-}"
        allow_args="${PS_TASK_ALLOW_ARGS:-1}"
        require_files="${PS_TASK_REQUIRE_FILES:-}"
        artifact_paths="${PS_TASK_ARTIFACT_PATHS:-}"
        strict_artifacts="${PS_TASK_STRICT_ARTIFACTS:-0}"

        require_nonempty "inputs.id" "${id}" || fail "inputs.id must not be empty"
        require_nonempty "inputs.title" "${title}" || fail "inputs.title must not be empty"
        require_nonempty "inputs.script" "${script_rel}" || fail "inputs.script must not be empty"

        require_regex \
          "inputs.id" \
          "${id}" \
          '^[A-Za-z0-9._-]+$' \
          "Expected A-Z a-z 0-9 . _ -" || fail "inputs.id has invalid format"
        if [[ "${id}" == *"/"* || "${id}" == *"\\"* ]]; then
          fail "inputs.id must not contain path separators"
        fi

        continue_on_error="$(require_bool "inputs.continue_on_error" "${continue_on_error}")"
        allow_args="$(require_bool "inputs.allow_args" "${allow_args}")"
        strict_artifacts="$(require_bool "inputs.strict_artifacts" "${strict_artifacts}")"

        if [[ "${allow_args}" == "0" && -n "${args}" ]]; then
          fail "args provided but allow_args=0"
        fi

        safe_relpath "${script_rel}" || {
          fail "inputs.script must be repo-relative without traversal (got: ${script_rel})"
        }
        if ! safe_relpath "${working_directory}"; then
          err_msg="inputs.working_directory must be repo-relative without traversal"
          err_msg="${err_msg} (got: ${working_directory})"
          fail "${err_msg}"
        fi

        repo_root_input="${GITHUB_WORKSPACE:-$(pwd)}"
        repo_root="$(
          resolve_abs_path "${repo_root_input}" 2>/dev/null || printf '%s' "${repo_root_input}"
        )"
        # Ensure GITHUB_OUTPUT is defined in local/test runs to avoid unbound variable on exit
        : "${GITHUB_OUTPUT:=${repo_root}/.github_output}"
        script_abs="${repo_root}/${script_rel}"
        working_directory_abs="${repo_root}/${working_directory}"
        check_under_root "${script_abs}"
        check_under_root "${working_directory_abs}"

        # ----------------------------------------------------------------------------
        # Canonical paths (declare early so we can write a report even on failure)
        # ----------------------------------------------------------------------------
        log_rel="logs/ps-task/${id}.log"
        report_rel="reports/ps-task/${id}.report.json"
        log_abs="${repo_root}/${log_rel}"
        report_abs="${repo_root}/${report_rel}"

        mkdir -p "${repo_root}/logs/ps-task" "${repo_root}/reports/ps-task"
        # Prevent symlink attacks and ensure restricted permissions on the log file
        if [[ -L "${log_abs}" ]]; then
          fail "unsafe log path: ${log_rel} is a symlink"
        fi
        umask 077
        : > "${log_abs}"
        chmod 600 "${log_abs}"

        # Tee everything into the task log
        exec > >(tee -a "${log_abs}") 2>&1

        start_ms="$(now_ms)"
        exit_code=0
        status="success"

        write_report_best_effort() {
          local s="${1:-failure}"
          local ec="${2:-1}"
          local end_ms dur
          end_ms="$(now_ms)"
          dur=$((end_ms - start_ms))

          emit_script="${repo_root}/tools/scripts/workflows/ci/emit-report.py"
          export REPORT_PATH="${report_abs}"
          export TASK_ID="${id}"
          export TASK_TITLE="${title}"
          export TASK_DESC="${desc}"
          export TASK_STATUS="${s}"
          export TASK_EXIT_CODE="${ec}"
          export TASK_DURATION_MS="${dur}"
          export TASK_LOG_PATH="${log_rel}"
          export TASK_REPORT_PATH="${report_rel}"
          export TASK_SCRIPT="${script_rel}"
          export TASK_WORKDIR="${working_directory}"

          if command -v python3 >/dev/null 2>&1 && [[ -f "${emit_script}" ]]; then
            python3 "${emit_script}"
          elif command -v python3 >/dev/null 2>&1; then
            python3 - <<'PY'
        import json, os
        p = {
          "id": os.environ.get("TASK_ID",""),
          "title": os.environ.get("TASK_TITLE",""),
          "description": os.environ.get("TASK_DESC",""),
          "status": os.environ.get("TASK_STATUS",""),
          "exit_code": int(os.environ.get("TASK_EXIT_CODE","0")),
          "duration_ms": int(os.environ.get("TASK_DURATION_MS","0")),
          "log_path": os.environ.get("TASK_LOG_PATH",""),
          "report_path": os.environ.get("TASK_REPORT_PATH",""),
          "script": os.environ.get("TASK_SCRIPT",""),
          "working_directory": os.environ.get("TASK_WORKDIR",""),
        }
        with open(os.environ["REPORT_PATH"], "w", encoding="utf-8") as f:
          json.dump(p, f, indent=2, sort_keys=True)
          f.write("\n")
        PY
          else
            # Minimal fallback JSON (no python dependency)
            cat > "${report_abs}" <<EOF
        {
          "id": "$(printf '%s' "${id}" | sed 's/"/\\"/g')",
          "title": "$(printf '%s' "${title}" | sed 's/"/\\"/g')",
          "description": "$(printf '%s' "${desc}" | sed 's/"/\\"/g')",
          "status": "${s}",
          "exit_code": ${ec},
          "duration_ms": ${dur},
          "log_path": "${log_rel}",
          "report_path": "${report_rel}",
          "script": "${script_rel}",
          "working_directory": "${working_directory}"
        }
        EOF
          fi
        }

        on_exit() {
          local ec="$?"
          if [[ "${ec}" -ne 0 ]]; then
            status="failure"
            exit_code="${ec}"
          fi
          write_report_best_effort "${status}" "${exit_code}"

          {
            echo "status=${status}"
            echo "log_path=${log_rel}"
            echo "report_path=${report_rel}"
            echo "duration_ms=$(( $(now_ms) - start_ms ))"
            echo "exit_code=${exit_code}"
          } >> "${GITHUB_OUTPUT}"
        }
        trap on_exit EXIT

        # ----------------------------------------------------------------------------
        # Preconditions
        # ----------------------------------------------------------------------------
        [[ -f "${script_abs}" ]] || fail "script not found: ${script_rel}"
        if [[ ! -d "${working_directory_abs}" ]]; then
          fail "working_directory not found: ${working_directory}"
        fi

        if [[ -n "${require_files}" ]]; then
          while IFS= read -r line; do
            item="$(trim "${line}")"
            [[ -z "${item}" ]] && continue
            safe_relpath "${item}" || {
              fail "require_files entry must be repo-relative without traversal (got: ${item})"
            }
            file_abs="${repo_root}/${item}"
            [[ -f "${file_abs}" ]] || fail "required file missing: ${item}"
            check_under_root "${file_abs}"
          done <<< "${require_files}"
        fi

        # Validate artifact_paths are safe globs (we'll match them later)
        if [[ -n "${artifact_paths}" ]]; then
          while IFS= read -r line; do
            item="$(trim "${line}")"
            [[ -z "${item}" ]] && continue
            safe_relpath "${item}" || {
              fail "artifact_paths entry must be repo-relative without traversal (got: ${item})"
            }
          done <<< "${artifact_paths}"
        fi

        printf 'PS.TASK: id=%s\n' "${id}"
        printf 'PS.TASK: title=%s\n' "${title}"
        [[ -n "${desc}" ]] && printf 'PS.TASK: description=%s\n' "${desc}"
        printf 'PS.TASK: script=%s\n' "${script_rel}"
        printf 'PS.TASK: working_directory=%s\n' "${working_directory}"

        # Log task identification for audit trail
        log_security_event "EVENT" "task_id=${id} title=${title}"

        # ----------------------------------------------------------------------------
        # env_kv parsing
        # ----------------------------------------------------------------------------
        env_args=()
        total_env_kv_bytes=0
        if [[ -n "${env_kv}" ]]; then
          while IFS= read -r line; do
            entry="$(trim "${line}")"
            [[ -z "${entry}" ]] && continue
            [[ "${entry}" == *=* ]] || fail "env_kv entries must be KEY=VALUE (got: ${entry})"
            key="${entry%%=*}"
            value="${entry#*=}"
            if [[ ! "${key}" =~ ^[A-Za-z_][A-Za-z0-9_]*$ ]]; then
              fail "env_kv key must be a valid identifier (got: ${key})"
            fi
            # strip CR
            value="${value//$'\r'/}"
            if [[ "${value}" == *$'\0'* ]]; then
              fail "env_kv value must not contain NUL bytes (key: ${key})"
            fi

            # enforce per-value and total size limits
            val_len=${#value}
            if (( val_len > MAX_ENV_KV_VALUE_BYTES )); then
              fail "env_kv value too large (key: ${key})"
            fi
            total_env_kv_bytes=$((total_env_kv_bytes + val_len))
            if (( total_env_kv_bytes > MAX_ENV_KV_TOTAL_BYTES )); then
              fail "env_kv total size too large"
            fi

            env_args+=("${key}=${value}")
          done <<< "${env_kv}"
        fi

        # Limit the number of env entries to prevent resource abuse
        env_kv_count=${#env_args[@]:-0}
        if (( env_kv_count > MAX_ENV_KV_ENTRIES )); then
          fail "env_kv has too many entries (${env_kv_count})"
        fi

        # Basic security logging for env_kv and args counts
        env_kv_count=${#env_args[@]}
        log_security_event "EVENT" "env_kv_processed count=${env_kv_count} task_id=${id}"

        args_array=()
        if [[ -n "${args}" ]]; then
          while IFS= read -r line; do
            item="$(trim "${line}")"
            [[ -z "${item}" ]] && continue
            args_array+=("${item}")
          done <<< "${args}"
        fi
        args_count=${#args_array[@]}
        log_security_event "EVENT" "args_processed count=${args_count} task_id=${id}"

        # ----------------------------------------------------------------------------
        # args parsing (simple; space-separated)
        # ----------------------------------------------------------------------------
        args_array=()
        if [[ -n "${args}" ]]; then
          while IFS= read -r line; do
            item="$(trim "${line}")"
            [[ -z "${item}" ]] && continue
            args_array+=("${item}")
          done <<< "${args}"
        fi

        # ----------------------------------------------------------------------------
        # Execute
        # ----------------------------------------------------------------------------
        # Log environment variable count for anomaly detection
        env_var_count=${#env_args[@]}
        if (( env_var_count > 10 )); then
          warn_msg="High number of environment variables: ${env_var_count} task_id=${id}"
          log_security_event "WARNING" "${warn_msg}"
        fi
        env_msg="env_vars_set count=${env_var_count} task_id=${id}"
        log_security_event "EVENT" "${env_msg}"

        # Log script execution and working directory for audit trail
        exec_msg="script_execution path=${script_rel} working_directory=${working_directory}"
        exec_msg="${exec_msg} task_id=${id}"
        log_security_event "EVENT" "${exec_msg}"

        set +e
        (
          cd "${working_directory_abs}"
          env "${env_args[@]}" bash "${script_abs}" "${args_array[@]}"
        )
        exit_code="$?"
        set -e

        if [[ "${exit_code}" -ne 0 ]]; then
          status="failure"
        fi

        # ----------------------------------------------------------------------------
        # Glob-aware artifact validation
        # ----------------------------------------------------------------------------
        if [[ -n "${artifact_paths}" ]]; then
          shopt -s globstar nullglob
          artifact_missing=0
          artifact_any=0

          while IFS= read -r line; do
            pat="$(trim "${line}")"
            [[ -z "${pat}" ]] && continue

            # Evaluate glob relative to repo root
            matches=( "${repo_root}"/${pat} )
            if [[ "${#matches[@]}" -eq 0 ]]; then
              if [[ "${strict_artifacts}" == "1" ]]; then
                printf 'PS.TASK: missing artifact glob match: %s\n' "${pat}"
                artifact_missing=1
              fi
            else
              artifact_any=1
              for match in "${matches[@]}"; do
                check_under_root "${match}"
              done
            fi
          done <<< "${artifact_paths}"

          if [[ "${strict_artifacts}" == "1" ]]; then
            if [[ "${artifact_missing}" -eq 1 ]]; then
              status="failure"
              [[ "${exit_code}" -eq 0 ]] && exit_code=1
            fi
          elif [[ "${artifact_any}" -eq 0 ]]; then
            status="failure"
            [[ "${exit_code}" -eq 0 ]] && exit_code=1
          fi
        fi

        # ----------------------------------------------------------------------------
        # Exit behaviour
        # ----------------------------------------------------------------------------
        if [[ "${status}" != "success" && "${continue_on_error}" == "0" ]]; then
          exit "${exit_code}"
        fi

        # If continue_on_error=1 we still exit 0; trap will write report + outputs.
        exit 0

    - name: Complete (PS)
      shell: bash
      run: |
        set -euo pipefail
        printf 'PS.TASK.RUN: OK\n'
