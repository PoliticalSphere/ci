# ==============================================================================
# Political Sphere â€” Composite Action: PS Task Runner
# ------------------------------------------------------------------------------
# Purpose:
#   Canonical task runner for repository scripts with uniform logging/reporting.
#
# Responsibilities:
#   - Validate inputs and path safety
#   - Enforce deterministic execution
#   - Validate required files before running
#   - Execute script and capture logs/report JSON
#
# ==============================================================================

name: "PS Task Runner"
description: "Canonical task runner with uniform logs and report outputs"

inputs:
  id:
    description: "Task identifier (machine-readable, used for logs/reports)"
    required: true

  title:
    description: "Human-readable task title"
    required: true

  description:
    description: "Task description"
    required: false
    default: ""

  script:
    description: "Script path to execute (repo-relative)"
    required: true

  working_directory:
    description: "Working directory to run from (repo-relative)"
    required: false
    default: "."

  working-directory:
    description: "Deprecated: use working_directory"
    required: false
    default: ""

  require_files:
    description: "Newline-separated list of required files (repo-relative)"
    required: false
    default: ""

  artifact_paths:
    description: "Newline-separated list of expected output paths (repo-relative)"
    required: false
    default: ""

  continue_on_error:
    description: "Continue on error (0|1)"
    required: false
    default: "0"

  env_kv:
    description: "Optional multiline KEY=VALUE environment pairs"
    required: false
    default: ""

  args:
    description: "Optional arguments to pass to the script (space-separated)"
    required: false
    default: ""

  allow_args:
    description: "Allow args passthrough (0|1)"
    required: false
    default: "1"

outputs:
  status:
    description: "Task status (success|failure)"
    value: ${{ steps.ps_task_run.outputs.status }}

  log_path:
    description: "Path to the task log"
    value: ${{ steps.ps_task_run.outputs.log_path }}

  report_path:
    description: "Path to the task report JSON"
    value: ${{ steps.ps_task_run.outputs.report_path }}

  duration_ms:
    description: "Task duration in milliseconds"
    value: ${{ steps.ps_task_run.outputs.duration_ms }}

  exit_code:
    description: "Exit code from the task script"
    value: ${{ steps.ps_task_run.outputs.exit_code }}

runs:
  using: "composite"
  steps:
    - name: Run task (PS)
      id: ps_task_run
      shell: bash
      env:
        PS_TASK_ID: ${{ inputs.id }}
        PS_TASK_TITLE: ${{ inputs.title }}
        PS_TASK_DESC: ${{ inputs.description }}
        PS_TASK_SCRIPT: ${{ inputs.script }}
        PS_TASK_WORKDIR: ${{ inputs.working_directory }}
        PS_TASK_WORKDIR_DASH: ${{ inputs['working-directory'] }}
        PS_TASK_REQUIRE_FILES: ${{ inputs.require_files }}
        PS_TASK_ARTIFACT_PATHS: ${{ inputs.artifact_paths }}
        PS_TASK_CONTINUE_ON_ERROR: ${{ inputs.continue_on_error }}
        PS_TASK_ENV_KV: ${{ inputs.env_kv }}
        PS_TASK_ARGS: ${{ inputs.args }}
        PS_TASK_ALLOW_ARGS: ${{ inputs.allow_args }}
      run: |
        set -euo pipefail

        now_ms() {
          if date +%s%3N >/dev/null 2>&1; then
            date +%s%3N
          else
            printf '%s000' "$(date +%s)"
          fi
        }

        fail() {
          printf 'ERROR: %s\n' "$*" >&2
          exit 1
        }

        safe_relpath() {
          case "$1" in
            "") return 1 ;;
            /*) return 1 ;;
            *".."*) return 1 ;;
            *) return 0 ;;
          esac
        }

        id="${PS_TASK_ID:-}"
        title="${PS_TASK_TITLE:-}"
        desc="${PS_TASK_DESC:-}"
        script_rel="${PS_TASK_SCRIPT:-}"
        working_directory_input="${PS_TASK_WORKDIR:-}"
        working_directory_dash="${PS_TASK_WORKDIR_DASH:-}"
        working_directory="${working_directory_input:-${working_directory_dash:-.}}"
        continue_on_error="${PS_TASK_CONTINUE_ON_ERROR:-0}"
        env_kv="${PS_TASK_ENV_KV:-}"
        args="${PS_TASK_ARGS:-}"
        allow_args="${PS_TASK_ALLOW_ARGS:-1}"

        [[ -n "${id}" ]] || fail "inputs.id must not be empty"
        [[ -n "${title}" ]] || fail "inputs.title must not be empty"
        [[ -n "${script_rel}" ]] || fail "inputs.script must not be empty"

        if ! [[ "${id}" =~ ^[A-Za-z0-9._-]+$ ]]; then
          fail "inputs.id must match [A-Za-z0-9._-]+ (got: ${id})"
        fi
        if [[ "${id}" == *".."* || "${id}" == *"/"* || "${id}" == *"\\"* ]]; then
          fail "inputs.id must not contain path separators or traversal"
        fi

        case "${continue_on_error}" in
          0|1) ;;
          *) fail "inputs.continue_on_error must be 0 or 1 (got: ${continue_on_error})" ;;
        esac

        case "${allow_args}" in
          0|1) ;;
          *) fail "inputs.allow_args must be 0 or 1 (got: ${allow_args})" ;;
        esac

        if [[ "${allow_args}" == "0" && -n "${args}" ]]; then
          fail "args provided but allow_args=0"
        fi

        safe_relpath "${script_rel}" || fail "inputs.script must be repo-relative without traversal (got: ${script_rel})"
        safe_relpath "${working_directory}" || fail "inputs.working_directory must be repo-relative without traversal (got: ${working_directory})"

        repo_root="${GITHUB_WORKSPACE:-$(pwd)}"
        script_abs="${repo_root}/${script_rel}"
        working_directory_abs="${repo_root}/${working_directory}"

        if [[ ! -f "${script_abs}" ]]; then
          fail "script not found: ${script_rel}"
        fi
        if [[ ! -d "${working_directory_abs}" ]]; then
          fail "working_directory not found: ${working_directory}"
        fi

        log_rel="logs/ps-task/${id}.log"
        report_rel="reports/ps-task/${id}.report.json"
        log_abs="${repo_root}/${log_rel}"
        report_abs="${repo_root}/${report_rel}"

        mkdir -p "${repo_root}/logs/ps-task" "${repo_root}/reports/ps-task"
        : > "${log_abs}"

        exec > >(tee -a "${log_abs}") 2>&1

        require_files="${PS_TASK_REQUIRE_FILES:-}"
        if [[ -n "${require_files}" ]]; then
          while IFS= read -r line; do
            item="$(printf '%s' "${line}" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
            [[ -z "${item}" ]] && continue
            safe_relpath "${item}" || fail "require_files entry must be repo-relative without traversal (got: ${item})"
            if [[ ! -f "${repo_root}/${item}" ]]; then
              fail "required file missing: ${item}"
            fi
          done <<< "${require_files}"
        fi

        artifact_paths="${PS_TASK_ARTIFACT_PATHS:-}"
        if [[ -n "${artifact_paths}" ]]; then
          while IFS= read -r line; do
            item="$(printf '%s' "${line}" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
            [[ -z "${item}" ]] && continue
            safe_relpath "${item}" || fail "artifact_paths entry must be repo-relative without traversal (got: ${item})"
          done <<< "${artifact_paths}"
        fi

        printf 'PS.TASK: id=%s\n' "${id}"
        printf 'PS.TASK: title=%s\n' "${title}"
        if [[ -n "${desc}" ]]; then
          printf 'PS.TASK: description=%s\n' "${desc}"
        fi
        printf 'PS.TASK: script=%s\n' "${script_rel}"
        printf 'PS.TASK: working_directory=%s\n' "${working_directory}"

        start_ms="$(now_ms)"

        env_args=()
        if [[ -n "${env_kv}" ]]; then
          while IFS= read -r line; do
            entry="$(printf '%s' "${line}" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
            [[ -z "${entry}" ]] && continue
            if [[ "${entry}" != *=* ]]; then
              fail "env_kv entries must be KEY=VALUE (got: ${entry})"
            fi
            key="${entry%%=*}"
            value="${entry#*=}"
            if ! [[ "${key}" =~ ^[A-Za-z_][A-Za-z0-9_]*$ ]]; then
              fail "env_kv key must be a valid identifier (got: ${key})"
            fi
            env_args+=("${key}=${value}")
          done <<< "${env_kv}"
        fi

        args_array=()
        if [[ -n "${args}" ]]; then
          read -r -a args_array <<< "${args}"
        fi

        exit_code=0
        status="success"

        set +e
        (
          cd "${working_directory_abs}"
          env "${env_args[@]}" bash "${script_abs}" "${args_array[@]}"
        )
        exit_code=$?
        set -e

        if [[ "${exit_code}" -ne 0 ]]; then
          status="failure"
        fi

        artifact_missing=0
        if [[ -n "${artifact_paths}" ]]; then
          while IFS= read -r line; do
            item="$(printf '%s' "${line}" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
            [[ -z "${item}" ]] && continue
            if [[ ! -e "${repo_root}/${item}" ]]; then
              printf 'PS.TASK: missing artifact path: %s\n' "${item}"
              artifact_missing=1
            fi
          done <<< "${artifact_paths}"
        fi

        if [[ "${artifact_missing}" -eq 1 ]]; then
          status="failure"
          if [[ "${exit_code}" -eq 0 ]]; then
            exit_code=1
          fi
        fi

        end_ms="$(now_ms)"
        duration_ms=$((end_ms - start_ms))

        export REPORT_PATH="${report_abs}"
        export TASK_ID="${id}"
        export TASK_TITLE="${title}"
        export TASK_DESC="${desc}"
        export TASK_STATUS="${status}"
        export TASK_EXIT_CODE="${exit_code}"
        export TASK_DURATION_MS="${duration_ms}"
        export TASK_LOG_PATH="${log_rel}"
        export TASK_REPORT_PATH="${report_rel}"
        export TASK_SCRIPT="${script_rel}"
        export TASK_WORKDIR="${working_directory}"

        python3 - <<'PY'
import json
import os

report_path = os.environ["REPORT_PATH"]

payload = {
    "id": os.environ.get("TASK_ID", ""),
    "title": os.environ.get("TASK_TITLE", ""),
    "description": os.environ.get("TASK_DESC", ""),
    "status": os.environ.get("TASK_STATUS", ""),
    "exit_code": int(os.environ.get("TASK_EXIT_CODE", "0")),
    "duration_ms": int(os.environ.get("TASK_DURATION_MS", "0")),
    "log_path": os.environ.get("TASK_LOG_PATH", ""),
    "report_path": os.environ.get("TASK_REPORT_PATH", ""),
    "script": os.environ.get("TASK_SCRIPT", ""),
    "working_directory": os.environ.get("TASK_WORKDIR", ""),
}

with open(report_path, "w", encoding="utf-8") as f:
    json.dump(payload, f, indent=2, sort_keys=True)
    f.write("\n")
PY

        {
          echo "status=${status}"
          echo "log_path=${log_rel}"
          echo "report_path=${report_rel}"
          echo "duration_ms=${duration_ms}"
          echo "exit_code=${exit_code}"
        } >> "${GITHUB_OUTPUT}"

        if [[ "${status}" != "success" && "${continue_on_error}" == "0" ]]; then
          exit "${exit_code}"
        fi
