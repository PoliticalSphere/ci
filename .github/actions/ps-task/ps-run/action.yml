# ==============================================================================
# Political Sphere — Composite Action: PS Task Runner
# ==============================================================================
#
# METADATA
# ------------------------------------------------------------------------------
# id: ps-run
# version: 1.1.0
# owner: political-sphere
# classification: internal
# created: 2025-12-26
# last_updated: 2025-12-26
#
# DEPENDENCIES
# ------------------------------------------------------------------------------
# - tools/scripts/ci/emit-report.py (optional; python3 required)
#
# DEPENDENTS
# ------------------------------------------------------------------------------
# - ./.github/actions/ps-task/* (task wrappers)
# - ./.github/actions/ps-bootstrap/ps-tools (security scans)
#
# PURPOSE
# ------------------------------------------------------------------------------
# Canonical task runner for repository scripts with uniform logging/reporting.
#
# SCOPE & RESPONSIBILITIES
# ------------------------------------------------------------------------------
# DOES:
#   - Validate inputs and path safety
#   - Enforce deterministic execution
#   - Validate required files before running
#   - Execute script and capture logs + report JSON (best-effort)
#   - Optionally validate expected outputs via glob-aware artifact_paths
#
# DOES NOT:
#   - Install dependencies
#   - Modify job permissions
#   - Perform repository checkout
#
# DESIGN PRINCIPLES
# ------------------------------------------------------------------------------
# - Deterministic, non-interactive execution
# - Repo-local path enforcement with realpath checks
# - Best-effort reporting even on failure
#
# SECURITY TIERING
# ------------------------------------------------------------------------------
# Level 1 — High (executes repository scripts with strict guardrails)
#
# THREAT MODEL
# ------------------------------------------------------------------------------
# Purpose: Prevents path traversal, argument splitting, and artifact spoofing
#          while preserving audit-ready logs for downstream systems.
#
# AUDIT LOG
# ------------------------------------------------------------------------------
# Records task outputs via structured JSON reports and canonical log paths.
#
# NOTES
# ------------------------------------------------------------------------------
# - artifact_paths entries are treated as globs (newline-separated).
# - A report is written best-effort even when validation fails early.
#
# ==============================================================================

name: "PS Task Runner"
description: "Canonical task runner with uniform logs and report outputs"

inputs:
  id:
    description: "Task identifier (machine-readable, used for logs/reports)"
    required: true

  title:
    description: "Human-readable task title"
    required: true

  description:
    description: "Task description"
    required: false
    default: ""

  script:
    description: "Script path to execute (repo-relative)"
    required: true

  working_directory:
    description: "Working directory to run from (repo-relative)"
    required: false
    default: "."

  working-directory:
    description: "Deprecated: use working_directory"
    required: false
    default: ""

  require_files:
    description: "Newline-separated list of required files (repo-relative)"
    required: false
    default: ""

  artifact_paths:
    description: "Newline-separated list of expected output paths/globs (repo-relative)"
    required: false
    default: ""

  continue_on_error:
    description: "Continue on error (0|1)"
    required: false
    default: "0"

  env_kv:
    description: "Optional multiline KEY=VALUE environment pairs"
    required: false
    default: ""

  args:
    description: "Optional arguments to pass to the script (newline-separated)"
    required: false
    default: ""

  allow_args:
    description: "Allow args passthrough (0|1)"
    required: false
    default: "1"

  strict_artifacts:
    description: "Require each artifact_paths pattern to match at least one file (0|1)"
    required: false
    default: "0"

outputs:
  status:
    description: "Task status (success|failure)"
    value: ${{ steps.ps_task_run.outputs.status }}

  log_path:
    description: "Path to the task log"
    value: ${{ steps.ps_task_run.outputs.log_path }}

  report_path:
    description: "Path to the task report JSON"
    value: ${{ steps.ps_task_run.outputs.report_path }}

  duration_ms:
    description: "Task duration in milliseconds"
    value: ${{ steps.ps_task_run.outputs.duration_ms }}

  exit_code:
    description: "Exit code from the task script"
    value: ${{ steps.ps_task_run.outputs.exit_code }}

runs:
  using: "composite"
  steps:
    - name: Run task (PS)
      id: ps_task_run
      shell: bash
      env:
        PS_TASK_ID: ${{ inputs.id }}
        PS_TASK_TITLE: ${{ inputs.title }}
        PS_TASK_DESC: ${{ inputs.description }}
        PS_TASK_SCRIPT: ${{ inputs.script }}
        PS_TASK_WORKDIR: ${{ inputs.working_directory }}
        PS_TASK_WORKDIR_DASH: ${{ inputs['working-directory'] }}
        PS_TASK_REQUIRE_FILES: ${{ inputs.require_files }}
        PS_TASK_ARTIFACT_PATHS: ${{ inputs.artifact_paths }}
        PS_TASK_CONTINUE_ON_ERROR: ${{ inputs.continue_on_error }}
        PS_TASK_ENV_KV: ${{ inputs.env_kv }}
        PS_TASK_ARGS: ${{ inputs.args }}
        PS_TASK_ALLOW_ARGS: ${{ inputs.allow_args }}
        PS_TASK_STRICT_ARTIFACTS: ${{ inputs.strict_artifacts }}
      run: |
        set -euo pipefail

        now_ms() {
          if date +%s%3N >/dev/null 2>&1; then
            date +%s%3N
          else
            printf '%s000' "$(date +%s)"
          fi
        }

        trim() {
          # shellcheck disable=SC2001
          printf '%s' "$1" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//'
        }

        fail() {
          printf 'ERROR: %s\n' "$*" >&2
          exit 1
        }

        # Safe repo-relative path:
        # - not empty
        # - not absolute
        # - no traversal segments (/../ or ../ or ..\)
        safe_relpath() {
          local p="$1"
          [[ -n "${p}" ]] || return 1
          [[ "${p}" != /* ]] || return 1
          [[ "${p}" != *".."* ]] || true
          # Reject traversal segments rather than any ".." substring.
          case "${p}" in
            *"/../"*|../*|*/..|*"\../"*|..\\*|*\\..|*"/.."|*"..\\" ) return 1 ;;
          esac
          return 0
        }

        resolve_abs_path() {
          local target="$1"
          if command -v python3 >/dev/null 2>&1; then
            python3 - <<'PY' "${target}"
        import os, sys
        target = sys.argv[1]
        print(os.path.realpath(target))
        PY
            return 0
          fi
          if command -v realpath >/dev/null 2>&1; then
            realpath -m -- "${target}"
            return 0
          fi
          if command -v readlink >/dev/null 2>&1; then
            readlink -f -- "${target}" 2>/dev/null || readlink -- "${target}"
            return 0
          fi
          return 1
        }

        check_under_root() {
          local target="$1"
          local resolved
          resolved="$(resolve_abs_path "${target}")" || fail "path resolver missing for security check: ${target}"
          case "${resolved}" in
            "${repo_root}"|${repo_root}/*) return 0 ;;
            *) fail "path escape detected: ${target} resolves outside workspace" ;;
          esac
        }

        # Security logging helper: sanitize and timestamp events
        log_security_event() {
          local level="$1"; shift
          local msg="$*"
          msg="$(printf '%s' "${msg}" | tr -d '\r\n' | tr -c '[:print:]\t' ' ')"
          local ts
          ts="$(date -u +%FT%T%z 2>/dev/null || date -u +%FT%T)"
          if [[ -n "${log_abs:-}" ]]; then
            printf '%s %s %s\n' "${ts}" "${level}" "${msg}" >> "${log_abs}"
          else
            printf '%s %s %s\n' "${ts}" "${level}" "${msg}"
          fi
        }

        # ----------------------------------------------------------------------------
        # Inputs
        # ----------------------------------------------------------------------------
        id="${PS_TASK_ID:-}"
        title="${PS_TASK_TITLE:-}"
        desc="${PS_TASK_DESC:-}"
        script_rel="${PS_TASK_SCRIPT:-}"

        workdir_input="${PS_TASK_WORKDIR:-}"
        workdir_dash="${PS_TASK_WORKDIR_DASH:-}"
        working_directory="${workdir_input:-${workdir_dash:-.}}"

        continue_on_error="${PS_TASK_CONTINUE_ON_ERROR:-0}"
        env_kv="${PS_TASK_ENV_KV:-}"
        args="${PS_TASK_ARGS:-}"
        allow_args="${PS_TASK_ALLOW_ARGS:-1}"
        require_files="${PS_TASK_REQUIRE_FILES:-}"
        artifact_paths="${PS_TASK_ARTIFACT_PATHS:-}"
        strict_artifacts="${PS_TASK_STRICT_ARTIFACTS:-0}"

        [[ -n "${id}" ]] || fail "inputs.id must not be empty"
        [[ -n "${title}" ]] || fail "inputs.title must not be empty"
        [[ -n "${script_rel}" ]] || fail "inputs.script must not be empty"

        if [[ -n "${workdir_dash}" && -z "${workdir_input}" ]]; then
          printf 'WARN: inputs.working-directory is deprecated; use inputs.working_directory\n'
        fi

        if ! [[ "${id}" =~ ^[A-Za-z0-9._-]+$ ]]; then
          fail "inputs.id must match [A-Za-z0-9._-]+ (got: ${id})"
        fi
        if [[ "${id}" == *"/"* || "${id}" == *"\\"* ]]; then
          fail "inputs.id must not contain path separators"
        fi

        case "${continue_on_error}" in
          0|1) ;;
          *) fail "inputs.continue_on_error must be 0 or 1 (got: ${continue_on_error})" ;;
        esac

        case "${allow_args}" in
          0|1) ;;
          *) fail "inputs.allow_args must be 0 or 1 (got: ${allow_args})" ;;
        esac

        case "${strict_artifacts}" in
          0|1) ;;
          *) fail "inputs.strict_artifacts must be 0 or 1 (got: ${strict_artifacts})" ;;
        esac

        if [[ "${allow_args}" == "0" && -n "${args}" ]]; then
          fail "args provided but allow_args=0"
        fi

        safe_relpath "${script_rel}" || fail "inputs.script must be repo-relative without traversal (got: ${script_rel})"
        safe_relpath "${working_directory}" || fail "inputs.working_directory must be repo-relative without traversal (got: ${working_directory})"

        repo_root_input="${GITHUB_WORKSPACE:-$(pwd)}"
        repo_root="$(resolve_abs_path "${repo_root_input}" 2>/dev/null || printf '%s' "${repo_root_input}")"
        script_abs="${repo_root}/${script_rel}"
        working_directory_abs="${repo_root}/${working_directory}"
        check_under_root "${script_abs}"
        check_under_root "${working_directory_abs}"

        # ----------------------------------------------------------------------------
        # Canonical paths (declare early so we can write a report even on failure)
        # ----------------------------------------------------------------------------
        log_rel="logs/ps-task/${id}.log"
        report_rel="reports/ps-task/${id}.report.json"
        log_abs="${repo_root}/${log_rel}"
        report_abs="${repo_root}/${report_rel}"

        mkdir -p "${repo_root}/logs/ps-task" "${repo_root}/reports/ps-task"
        # Prevent symlink attacks and ensure restricted permissions on the log file
        if [[ -L "${log_abs}" ]]; then
          fail "unsafe log path: ${log_rel} is a symlink"
        fi
        umask 077
        : > "${log_abs}"
        chmod 600 "${log_abs}"

        # Tee everything into the task log
        exec > >(tee -a "${log_abs}") 2>&1

        start_ms="$(now_ms)"
        exit_code=0
        status="success"

        write_report_best_effort() {
          local s="${1:-failure}"
          local ec="${2:-1}"
          local end_ms dur
          end_ms="$(now_ms)"
          dur=$((end_ms - start_ms))

          emit_script="${repo_root}/tools/scripts/ci/emit-report.py"
          if command -v python3 >/dev/null 2>&1 && [[ -f "${emit_script}" ]]; then
            REPORT_PATH="${report_abs}" \
            TASK_ID="${id}" \
            TASK_TITLE="${title}" \
            TASK_DESC="${desc}" \
            TASK_STATUS="${s}" \
            TASK_EXIT_CODE="${ec}" \
            TASK_DURATION_MS="${dur}" \
            TASK_LOG_PATH="${log_rel}" \
            TASK_REPORT_PATH="${report_rel}" \
            TASK_SCRIPT="${script_rel}" \
            TASK_WORKDIR="${working_directory}" \
            python3 "${emit_script}"
          elif command -v python3 >/dev/null 2>&1; then
            REPORT_PATH="${report_abs}" \
            TASK_ID="${id}" \
            TASK_TITLE="${title}" \
            TASK_DESC="${desc}" \
            TASK_STATUS="${s}" \
            TASK_EXIT_CODE="${ec}" \
            TASK_DURATION_MS="${dur}" \
            TASK_LOG_PATH="${log_rel}" \
            TASK_REPORT_PATH="${report_rel}" \
            TASK_SCRIPT="${script_rel}" \
            TASK_WORKDIR="${working_directory}" \
            python3 - <<'PY'
        import json, os
        p = {
          "id": os.environ.get("TASK_ID",""),
          "title": os.environ.get("TASK_TITLE",""),
          "description": os.environ.get("TASK_DESC",""),
          "status": os.environ.get("TASK_STATUS",""),
          "exit_code": int(os.environ.get("TASK_EXIT_CODE","0")),
          "duration_ms": int(os.environ.get("TASK_DURATION_MS","0")),
          "log_path": os.environ.get("TASK_LOG_PATH",""),
          "report_path": os.environ.get("TASK_REPORT_PATH",""),
          "script": os.environ.get("TASK_SCRIPT",""),
          "working_directory": os.environ.get("TASK_WORKDIR",""),
        }
        with open(os.environ["REPORT_PATH"], "w", encoding="utf-8") as f:
          json.dump(p, f, indent=2, sort_keys=True)
          f.write("\n")
        PY
          else
            # Minimal fallback JSON (no python dependency)
            cat > "${report_abs}" <<EOF
        {
          "id": "$(printf '%s' "${id}" | sed 's/"/\\"/g')",
          "title": "$(printf '%s' "${title}" | sed 's/"/\\"/g')",
          "description": "$(printf '%s' "${desc}" | sed 's/"/\\"/g')",
          "status": "${s}",
          "exit_code": ${ec},
          "duration_ms": ${dur},
          "log_path": "${log_rel}",
          "report_path": "${report_rel}",
          "script": "${script_rel}",
          "working_directory": "${working_directory}"
        }
        EOF
          fi
        }

        on_exit() {
          local ec="$?"
          if [[ "${ec}" -ne 0 ]]; then
            status="failure"
            exit_code="${ec}"
          fi
          write_report_best_effort "${status}" "${exit_code}"

          {
            echo "status=${status}"
            echo "log_path=${log_rel}"
            echo "report_path=${report_rel}"
            echo "duration_ms=$(( $(now_ms) - start_ms ))"
            echo "exit_code=${exit_code}"
          } >> "${GITHUB_OUTPUT}"
        }
        trap on_exit EXIT

        # ----------------------------------------------------------------------------
        # Preconditions
        # ----------------------------------------------------------------------------
        [[ -f "${script_abs}" ]] || fail "script not found: ${script_rel}"
        [[ -d "${working_directory_abs}" ]] || fail "working_directory not found: ${working_directory}"

        if [[ -n "${require_files}" ]]; then
          while IFS= read -r line; do
            item="$(trim "${line}")"
            [[ -z "${item}" ]] && continue
            safe_relpath "${item}" || fail "require_files entry must be repo-relative without traversal (got: ${item})"
            file_abs="${repo_root}/${item}"
            [[ -f "${file_abs}" ]] || fail "required file missing: ${item}"
            check_under_root "${file_abs}"
          done <<< "${require_files}"
        fi

        # Validate artifact_paths are safe globs (we'll match them later)
        if [[ -n "${artifact_paths}" ]]; then
          while IFS= read -r line; do
            item="$(trim "${line}")"
            [[ -z "${item}" ]] && continue
            safe_relpath "${item}" || fail "artifact_paths entry must be repo-relative without traversal (got: ${item})"
          done <<< "${artifact_paths}"
        fi

        printf 'PS.TASK: id=%s\n' "${id}"
        printf 'PS.TASK: title=%s\n' "${title}"
        [[ -n "${desc}" ]] && printf 'PS.TASK: description=%s\n' "${desc}"
        printf 'PS.TASK: script=%s\n' "${script_rel}"
        printf 'PS.TASK: working_directory=%s\n' "${working_directory}"

        # Log task identification for audit trail
        log_security_event "EVENT" "task_id=${id} title=${title}"

        # ----------------------------------------------------------------------------
        # env_kv parsing
        # ----------------------------------------------------------------------------
        env_args=()
        total_env_kv_bytes=0
        if [[ -n "${env_kv}" ]]; then
          while IFS= read -r line; do
            entry="$(trim "${line}")"
            [[ -z "${entry}" ]] && continue
            [[ "${entry}" == *=* ]] || fail "env_kv entries must be KEY=VALUE (got: ${entry})"
            key="${entry%%=*}"
            value="${entry#*=}"
            [[ "${key}" =~ ^[A-Za-z_][A-Za-z0-9_]*$ ]] || fail "env_kv key must be a valid identifier (got: ${key})"
            # strip CR
            value="${value//$'\r'/}"
            [[ "${value}" != *$'\0'* ]] || fail "env_kv value must not contain NUL bytes (key: ${key})"

            # enforce per-value and total size limits
            val_len=${#value}
            if (( val_len > 65536 )); then
              fail "env_kv value too large (key: ${key})"
            fi
            total_env_kv_bytes=$((total_env_kv_bytes + val_len))
            if (( total_env_kv_bytes > 262144 )); then
              fail "env_kv total size too large"
            fi

            env_args+=("${key}=${value}")
          done <<< "${env_kv}"
        fi

        # Limit the number of env entries to prevent resource abuse
        env_kv_count=${#env_args[@]:-0}
        if (( env_kv_count > 100 )); then
          fail "env_kv has too many entries (${env_kv_count})"
        fi

        # Basic security logging for env_kv and args counts
        env_kv_count=${#env_args[@]}
        log_security_event "EVENT" "env_kv_processed count=${env_kv_count} task_id=${id}"

        args_array=()
        if [[ -n "${args}" ]]; then
          while IFS= read -r line; do
            item="$(trim "${line}")"
            [[ -z "${item}" ]] && continue
            args_array+=("${item}")
          done <<< "${args}"
        fi
        args_count=${#args_array[@]}
        log_security_event "EVENT" "args_processed count=${args_count} task_id=${id}"

        # ----------------------------------------------------------------------------
        # args parsing (simple; space-separated)
        # ----------------------------------------------------------------------------
        args_array=()
        if [[ -n "${args}" ]]; then
          while IFS= read -r line; do
            item="$(trim "${line}")"
            [[ -z "${item}" ]] && continue
            args_array+=("${item}")
          done <<< "${args}"
        fi

        # ----------------------------------------------------------------------------
        # Execute
        # ----------------------------------------------------------------------------
        # Log environment variable count for anomaly detection
        env_var_count=${#env_args[@]}
        if (( env_var_count > 10 )); then
            log_security_event "WARNING" "High number of environment variables: ${env_var_count} task_id=${id}"
        fi
        log_security_event "EVENT" "env_vars_set count=${env_var_count} task_id=${id}"

        # Log script execution and working directory for audit trail
        log_security_event "EVENT" "script_execution path=${script_rel} working_directory=${working_directory} task_id=${id}"

        set +e
        (
          cd "${working_directory_abs}"
          env "${env_args[@]}" bash "${script_abs}" "${args_array[@]}"
        )
        exit_code="$?"
        set -e

        if [[ "${exit_code}" -ne 0 ]]; then
          status="failure"
        fi

        # ----------------------------------------------------------------------------
        # Glob-aware artifact validation
        # ----------------------------------------------------------------------------
        if [[ -n "${artifact_paths}" ]]; then
          shopt -s globstar nullglob
          artifact_missing=0
          artifact_any=0

          while IFS= read -r line; do
            pat="$(trim "${line}")"
            [[ -z "${pat}" ]] && continue

            # Evaluate glob relative to repo root
            matches=( "${repo_root}"/${pat} )
            if [[ "${#matches[@]}" -eq 0 ]]; then
              if [[ "${strict_artifacts}" == "1" ]]; then
                printf 'PS.TASK: missing artifact glob match: %s\n' "${pat}"
                artifact_missing=1
              fi
            else
              artifact_any=1
              for match in "${matches[@]}"; do
                check_under_root "${match}"
              done
            fi
          done <<< "${artifact_paths}"

          if [[ "${strict_artifacts}" == "1" ]]; then
            if [[ "${artifact_missing}" -eq 1 ]]; then
              status="failure"
              [[ "${exit_code}" -eq 0 ]] && exit_code=1
            fi
          elif [[ "${artifact_any}" -eq 0 ]]; then
            status="failure"
            [[ "${exit_code}" -eq 0 ]] && exit_code=1
          fi
        fi

        # ----------------------------------------------------------------------------
        # Exit behaviour
        # ----------------------------------------------------------------------------
        if [[ "${status}" != "success" && "${continue_on_error}" == "0" ]]; then
          exit "${exit_code}"
        fi

        # If continue_on_error=1 we still exit 0; trap will write report + outputs.
        exit 0
