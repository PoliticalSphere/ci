# ==============================================================================
# Political Sphere â€” Composite Action: PS Task Runner
# ------------------------------------------------------------------------------
# Purpose:
#   Canonical task runner for repository scripts with uniform logging/reporting.
#
# Responsibilities:
#   - Validate inputs and path safety
#   - Enforce deterministic execution
#   - Validate required files before running
#   - Execute script and capture logs + report JSON (best-effort)
#   - Optionally validate expected outputs via glob-aware artifact_paths
#
# Notes:
#   - artifact_paths entries are treated as globs (newline-separated).
#   - A report is written best-effort even when validation fails early.
# ==============================================================================

name: "PS Task Runner"
description: "Canonical task runner with uniform logs and report outputs"

inputs:
  id:
    description: "Task identifier (machine-readable, used for logs/reports)"
    required: true

  title:
    description: "Human-readable task title"
    required: true

  description:
    description: "Task description"
    required: false
    default: ""

  script:
    description: "Script path to execute (repo-relative)"
    required: true

  working_directory:
    description: "Working directory to run from (repo-relative)"
    required: false
    default: "."

  working-directory:
    description: "Deprecated: use working_directory"
    required: false
    default: ""

  require_files:
    description: "Newline-separated list of required files (repo-relative)"
    required: false
    default: ""

  artifact_paths:
    description: "Newline-separated list of expected output paths/globs (repo-relative)"
    required: false
    default: ""

  continue_on_error:
    description: "Continue on error (0|1)"
    required: false
    default: "0"

  env_kv:
    description: "Optional multiline KEY=VALUE environment pairs"
    required: false
    default: ""

  args:
    description: "Optional arguments to pass to the script (space-separated)"
    required: false
    default: ""

  allow_args:
    description: "Allow args passthrough (0|1)"
    required: false
    default: "1"

outputs:
  status:
    description: "Task status (success|failure)"
    value: ${{ steps.ps_task_run.outputs.status }}

  log_path:
    description: "Path to the task log"
    value: ${{ steps.ps_task_run.outputs.log_path }}

  report_path:
    description: "Path to the task report JSON"
    value: ${{ steps.ps_task_run.outputs.report_path }}

  duration_ms:
    description: "Task duration in milliseconds"
    value: ${{ steps.ps_task_run.outputs.duration_ms }}

  exit_code:
    description: "Exit code from the task script"
    value: ${{ steps.ps_task_run.outputs.exit_code }}

runs:
  using: "composite"
  steps:
    - name: Run task (PS)
      id: ps_task_run
      shell: bash
      env:
        PS_TASK_ID: ${{ inputs.id }}
        PS_TASK_TITLE: ${{ inputs.title }}
        PS_TASK_DESC: ${{ inputs.description }}
        PS_TASK_SCRIPT: ${{ inputs.script }}
        PS_TASK_WORKDIR: ${{ inputs.working_directory }}
        PS_TASK_WORKDIR_DASH: ${{ inputs['working-directory'] }}
        PS_TASK_REQUIRE_FILES: ${{ inputs.require_files }}
        PS_TASK_ARTIFACT_PATHS: ${{ inputs.artifact_paths }}
        PS_TASK_CONTINUE_ON_ERROR: ${{ inputs.continue_on_error }}
        PS_TASK_ENV_KV: ${{ inputs.env_kv }}
        PS_TASK_ARGS: ${{ inputs.args }}
        PS_TASK_ALLOW_ARGS: ${{ inputs.allow_args }}
      run: |
        set -euo pipefail

        now_ms() {
          if date +%s%3N >/dev/null 2>&1; then
            date +%s%3N
          else
            printf '%s000' "$(date +%s)"
          fi
        }

        trim() {
          # shellcheck disable=SC2001
          printf '%s' "$1" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//'
        }

        fail() {
          printf 'ERROR: %s\n' "$*" >&2
          exit 1
        }

        # Safe repo-relative path:
        # - not empty
        # - not absolute
        # - no traversal segments (/../ or ../ or ..\)
        safe_relpath() {
          local p="$1"
          [[ -n "${p}" ]] || return 1
          [[ "${p}" != /* ]] || return 1
          [[ "${p}" != *".."* ]] || true
          # Reject traversal segments rather than any ".." substring.
          case "${p}" in
            *"/../"*|../*|*/..|*"\../"*|..\\*|*\\..|*"/.."|*"..\\" ) return 1 ;;
          esac
          return 0
        }

        # ----------------------------------------------------------------------------
        # Inputs
        # ----------------------------------------------------------------------------
        id="${PS_TASK_ID:-}"
        title="${PS_TASK_TITLE:-}"
        desc="${PS_TASK_DESC:-}"
        script_rel="${PS_TASK_SCRIPT:-}"

        workdir_input="${PS_TASK_WORKDIR:-}"
        workdir_dash="${PS_TASK_WORKDIR_DASH:-}"
        working_directory="${workdir_input:-${workdir_dash:-.}}"

        continue_on_error="${PS_TASK_CONTINUE_ON_ERROR:-0}"
        env_kv="${PS_TASK_ENV_KV:-}"
        args="${PS_TASK_ARGS:-}"
        allow_args="${PS_TASK_ALLOW_ARGS:-1}"
        require_files="${PS_TASK_REQUIRE_FILES:-}"
        artifact_paths="${PS_TASK_ARTIFACT_PATHS:-}"

        [[ -n "${id}" ]] || fail "inputs.id must not be empty"
        [[ -n "${title}" ]] || fail "inputs.title must not be empty"
        [[ -n "${script_rel}" ]] || fail "inputs.script must not be empty"

        if [[ -n "${workdir_dash}" && -z "${workdir_input}" ]]; then
          printf 'WARN: inputs.working-directory is deprecated; use inputs.working_directory\n'
        fi

        if ! [[ "${id}" =~ ^[A-Za-z0-9._-]+$ ]]; then
          fail "inputs.id must match [A-Za-z0-9._-]+ (got: ${id})"
        fi
        if [[ "${id}" == *"/"* || "${id}" == *"\\"* ]]; then
          fail "inputs.id must not contain path separators"
        fi

        case "${continue_on_error}" in
          0|1) ;;
          *) fail "inputs.continue_on_error must be 0 or 1 (got: ${continue_on_error})" ;;
        esac

        case "${allow_args}" in
          0|1) ;;
          *) fail "inputs.allow_args must be 0 or 1 (got: ${allow_args})" ;;
        esac

        if [[ "${allow_args}" == "0" && -n "${args}" ]]; then
          fail "args provided but allow_args=0"
        fi

        safe_relpath "${script_rel}" || fail "inputs.script must be repo-relative without traversal (got: ${script_rel})"
        safe_relpath "${working_directory}" || fail "inputs.working_directory must be repo-relative without traversal (got: ${working_directory})"

        repo_root="${GITHUB_WORKSPACE:-$(pwd)}"
        script_abs="${repo_root}/${script_rel}"
        working_directory_abs="${repo_root}/${working_directory}"

        # ----------------------------------------------------------------------------
        # Canonical paths (declare early so we can write a report even on failure)
        # ----------------------------------------------------------------------------
        log_rel="logs/ps-task/${id}.log"
        report_rel="reports/ps-task/${id}.report.json"
        log_abs="${repo_root}/${log_rel}"
        report_abs="${repo_root}/${report_rel}"

        mkdir -p "${repo_root}/logs/ps-task" "${repo_root}/reports/ps-task"
        : > "${log_abs}"

        # Tee everything into the task log
        exec > >(tee -a "${log_abs}") 2>&1

        start_ms="$(now_ms)"
        exit_code=0
        status="success"

        write_report_best_effort() {
          local s="${1:-failure}"
          local ec="${2:-1}"
          local end_ms dur
          end_ms="$(now_ms)"
          dur=$((end_ms - start_ms))

          if command -v python3 >/dev/null 2>&1; then
            REPORT_PATH="${report_abs}" \
            TASK_ID="${id}" \
            TASK_TITLE="${title}" \
            TASK_DESC="${desc}" \
            TASK_STATUS="${s}" \
            TASK_EXIT_CODE="${ec}" \
            TASK_DURATION_MS="${dur}" \
            TASK_LOG_PATH="${log_rel}" \
            TASK_REPORT_PATH="${report_rel}" \
            TASK_SCRIPT="${script_rel}" \
            TASK_WORKDIR="${working_directory}" \
            python3 - <<'PY'
        import json, os
        p = {
          "id": os.environ.get("TASK_ID",""),
          "title": os.environ.get("TASK_TITLE",""),
          "description": os.environ.get("TASK_DESC",""),
          "status": os.environ.get("TASK_STATUS",""),
          "exit_code": int(os.environ.get("TASK_EXIT_CODE","0")),
          "duration_ms": int(os.environ.get("TASK_DURATION_MS","0")),
          "log_path": os.environ.get("TASK_LOG_PATH",""),
          "report_path": os.environ.get("TASK_REPORT_PATH",""),
          "script": os.environ.get("TASK_SCRIPT",""),
          "working_directory": os.environ.get("TASK_WORKDIR",""),
        }
        with open(os.environ["REPORT_PATH"], "w", encoding="utf-8") as f:
          json.dump(p, f, indent=2, sort_keys=True)
          f.write("\n")
        PY
          else
            # Minimal fallback JSON (no python dependency)
            cat > "${report_abs}" <<EOF
        {
          "id": "$(printf '%s' "${id}" | sed 's/"/\\"/g')",
          "title": "$(printf '%s' "${title}" | sed 's/"/\\"/g')",
          "description": "$(printf '%s' "${desc}" | sed 's/"/\\"/g')",
          "status": "${s}",
          "exit_code": ${ec},
          "duration_ms": ${dur},
          "log_path": "${log_rel}",
          "report_path": "${report_rel}",
          "script": "${script_rel}",
          "working_directory": "${working_directory}"
        }
        EOF
          fi
        }

        on_exit() {
          local ec="$?"
          if [[ "${ec}" -ne 0 ]]; then
            status="failure"
            exit_code="${ec}"
          fi
          write_report_best_effort "${status}" "${exit_code}"

          {
            echo "status=${status}"
            echo "log_path=${log_rel}"
            echo "report_path=${report_rel}"
            echo "duration_ms=$(( $(now_ms) - start_ms ))"
            echo "exit_code=${exit_code}"
          } >> "${GITHUB_OUTPUT}"
        }
        trap on_exit EXIT

        # ----------------------------------------------------------------------------
        # Preconditions
        # ----------------------------------------------------------------------------
        [[ -f "${script_abs}" ]] || fail "script not found: ${script_rel}"
        [[ -d "${working_directory_abs}" ]] || fail "working_directory not found: ${working_directory}"

        if [[ -n "${require_files}" ]]; then
          while IFS= read -r line; do
            item="$(trim "${line}")"
            [[ -z "${item}" ]] && continue
            safe_relpath "${item}" || fail "require_files entry must be repo-relative without traversal (got: ${item})"
            [[ -f "${repo_root}/${item}" ]] || fail "required file missing: ${item}"
          done <<< "${require_files}"
        fi

        # Validate artifact_paths are safe globs (we'll match them later)
        if [[ -n "${artifact_paths}" ]]; then
          while IFS= read -r line; do
            item="$(trim "${line}")"
            [[ -z "${item}" ]] && continue
            safe_relpath "${item}" || fail "artifact_paths entry must be repo-relative without traversal (got: ${item})"
          done <<< "${artifact_paths}"
        fi

        printf 'PS.TASK: id=%s\n' "${id}"
        printf 'PS.TASK: title=%s\n' "${title}"
        [[ -n "${desc}" ]] && printf 'PS.TASK: description=%s\n' "${desc}"
        printf 'PS.TASK: script=%s\n' "${script_rel}"
        printf 'PS.TASK: working_directory=%s\n' "${working_directory}"

        # ----------------------------------------------------------------------------
        # env_kv parsing
        # ----------------------------------------------------------------------------
        env_args=()
        if [[ -n "${env_kv}" ]]; then
          while IFS= read -r line; do
            entry="$(trim "${line}")"
            [[ -z "${entry}" ]] && continue
            [[ "${entry}" == *=* ]] || fail "env_kv entries must be KEY=VALUE (got: ${entry})"
            key="${entry%%=*}"
            value="${entry#*=}"
            [[ "${key}" =~ ^[A-Za-z_][A-Za-z0-9_]*$ ]] || fail "env_kv key must be a valid identifier (got: ${key})"
            env_args+=("${key}=${value}")
          done <<< "${env_kv}"
        fi

        # ----------------------------------------------------------------------------
        # args parsing (simple; space-separated)
        # ----------------------------------------------------------------------------
        args_array=()
        if [[ -n "${args}" ]]; then
          read -r -a args_array <<< "${args}"
        fi

        # ----------------------------------------------------------------------------
        # Execute
        # ----------------------------------------------------------------------------
        set +e
        (
          cd "${working_directory_abs}"
          env "${env_args[@]}" bash "${script_abs}" "${args_array[@]}"
        )
        exit_code="$?"
        set -e

        if [[ "${exit_code}" -ne 0 ]]; then
          status="failure"
        fi

        # ----------------------------------------------------------------------------
        # Glob-aware artifact validation
        # ----------------------------------------------------------------------------
        if [[ -n "${artifact_paths}" ]]; then
          shopt -s globstar nullglob
          artifact_missing=0

          while IFS= read -r line; do
            pat="$(trim "${line}")"
            [[ -z "${pat}" ]] && continue

            # Evaluate glob relative to repo root
            matches=( "${repo_root}"/${pat} )
            if [[ "${#matches[@]}" -eq 0 ]]; then
              printf 'PS.TASK: missing artifact glob match: %s\n' "${pat}"
              artifact_missing=1
            fi
          done <<< "${artifact_paths}"

          if [[ "${artifact_missing}" -eq 1 ]]; then
            status="failure"
            [[ "${exit_code}" -eq 0 ]] && exit_code=1
          fi
        fi

        # ----------------------------------------------------------------------------
        # Exit behaviour
        # ----------------------------------------------------------------------------
        if [[ "${status}" != "success" && "${continue_on_error}" == "0" ]]; then
          exit "${exit_code}"
        fi

        # If continue_on_error=1 we still exit 0; trap will write report + outputs.
        exit 0
