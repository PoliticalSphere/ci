# ==============================================================================
# Political Sphere — Composite Action: PS Checkout (Platform)
# ==============================================================================
#
# METADATA
# ------------------------------------------------------------------------------
# id: ps-checkout-platform
# version: 1.1.0
# owner: political-sphere
# classification: internal
# created: 2025-12-26
# last_updated: 2025-12-26
#
# DEPENDENCIES
# ------------------------------------------------------------------------------
# - actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8
#
# DEPENDENTS
# ------------------------------------------------------------------------------
# - ./.github/actions/ps-bootstrap/ps-init
#
# PURPOSE
# ------------------------------------------------------------------------------
# Standardise *platform repository* checkout with validated inputs, pinned
# dependencies, and stable outputs. This is intentionally separate from target
# repository checkout to keep semantics unambiguous and contracts stable.
#
# DESIGN PRINCIPLES
# ------------------------------------------------------------------------------
# - Deterministic, non-interactive execution
# - Minimal stable input surface with explicit validation
# - Safe path handling (repo-relative, no traversal)
# - Optional guardrails for internal-only platform repos
# - Emits stable outputs for downstream steps (telemetry + reuse)
#
# SECURITY TIERING
# ------------------------------------------------------------------------------
# Level 0 — Critical (this action controls platform repo ingress and trust
#                    boundaries for shared CI scripts)
#
# THREAT MODEL
# ------------------------------------------------------------------------------
# Purpose: Prevents unauthorized platform repository access, workspace escape,
#          and stale artifact reuse through strict allowlisting and path checks.
#
# AUDIT LOG
# ------------------------------------------------------------------------------
# Records validated platform checkout parameters via logs and outputs to
# support traceability in CI audits.
#
# ==============================================================================

name: "PS Checkout (Platform)"
description: "Checkout platform repository into a controlled path (validated + pinned)"

inputs:
  repository:
    description: "Platform repository in OWNER/REPO form (e.g. PoliticalSphere/ci)"
    required: true

  ref:
    description: "Git ref (branch, tag, or SHA) to checkout"
    required: false
    default: "main"

  path:
    description: "Checkout path relative to github.workspace (e.g. .ps-platform)"
    required: false
    default: ".ps-platform"

  fetch_depth:
    description: "Git fetch depth (0 = full history, default: 1)"
    required: false
    default: "1"

  persist_credentials:
    description: "Whether to persist credentials in the git config (true|false)"
    required: false
    default: "false"

  submodules:
    description: "Submodules mode: false|true|recursive"
    required: false
    default: "false"

  require_full_history:
    description: "Require fetch_depth=0 (true|false)"
    required: false
    default: "false"

  clean_path:
    description: >-
      Delete the target path before checkout (true|false). Use true to avoid
      dirty-tree conflicts.
    required: false
    default: "false"

  require_pinned_ref:
    description: >-
      Require platform ref to be a full 40-char commit SHA (true|false).
    required: false
    default: "false"

  allowed_repositories:
    description: >-
      Optional newline-separated allowlist of OWNER/REPO values. If set,
      repository must be in the list.
    required: false
    default: ""

outputs:
  platform_path:
    description: "Repo-relative path used for platform checkout"
    value: ${{ steps.ps_checkout_platform_outputs.outputs.platform_path }}

  platform_path_abs:
    description: "Absolute path to the platform checkout directory"
    value: ${{ steps.ps_checkout_platform_outputs.outputs.platform_path_abs }}

  platform_repository:
    description: "Validated platform repository (OWNER/REPO)"
    value: ${{ steps.ps_checkout_platform_outputs.outputs.platform_repository }}

  platform_ref:
    description: "Validated platform ref"
    value: ${{ steps.ps_checkout_platform_outputs.outputs.platform_ref }}

runs:
  using: "composite"
  steps:
    - name: Validate inputs (PS)
      shell: bash
      env:
        PS_REPOSITORY_INPUT: ${{ inputs.repository }}
        PS_REF_INPUT: ${{ inputs.ref }}
        PS_PATH_INPUT: ${{ inputs.path }}
        PS_FETCH_DEPTH_INPUT: ${{ inputs.fetch_depth }}
        PS_PERSIST_CREDENTIALS_INPUT: ${{ inputs.persist_credentials }}
        PS_SUBMODULES_INPUT: ${{ inputs.submodules }}
        PS_REQUIRE_FULL_HISTORY_INPUT: ${{ inputs.require_full_history }}
        PS_CLEAN_PATH_INPUT: ${{ inputs.clean_path }}
        PS_REQUIRE_PINNED_REF_INPUT: ${{ inputs.require_pinned_ref }}
        PS_ALLOWED_REPOSITORIES_INPUT: ${{ inputs.allowed_repositories }}
      run: |
        set -euo pipefail

        format_sh="${GITHUB_WORKSPACE}/tools/scripts/branding/format.sh"
        if [[ -f "${format_sh}" ]]; then
          # shellcheck source=/dev/null
          . "${format_sh}"
        fi

        log_info() {
          if type -t ps_detail >/dev/null 2>&1; then
            ps_detail "$*"
          else
            printf 'PS.CHECKOUT.PLATFORM: %s\n' "$*"
          fi
        }

        emit_env() {
          local key="$1"
          local val="$2"
          local sanitized delimiter attempts
          sanitized="${val//$'\r'/}"
          delimiter="__PS_ENV_${RANDOM}_${RANDOM}__"
          attempts=0
          while [[ "${sanitized}" == *"${delimiter}"* ]]; do
            attempts=$((attempts + 1))
            if [[ "${attempts}" -gt 6 ]]; then
              printf 'ERROR: env value for %s contains an unsafe heredoc delimiter\n' "${key}" >&2
              exit 1
            fi
            delimiter="__PS_ENV_${RANDOM}_${RANDOM}__"
          done
          printf '%s<<%s\n%s\n%s\n' \
            "${key}" "${delimiter}" "${sanitized}" "${delimiter}" \
            >> "${GITHUB_ENV}"
        }

        repo="${PS_REPOSITORY_INPUT:-}"
        if [[ -z "${repo}" ]]; then
          printf 'ERROR: inputs.repository is required\n' >&2
          exit 1
        fi
        if ! [[ "${repo}" =~ ^[A-Za-z0-9_.-]+/[A-Za-z0-9_.-]+$ ]]; then
          printf 'ERROR: inputs.repository must be OWNER/REPO (got %q)\n' "${repo}" >&2
          exit 1
        fi

        allowlist="${PS_ALLOWED_REPOSITORIES_INPUT:-}"
        if [[ -z "${allowlist}" ]]; then
          owner="${repo%%/*}"
          if [[ "${owner}" != "PoliticalSphere" ]]; then
            printf 'ERROR: inputs.repository owner must be PoliticalSphere unless allowlisted ' \
              '(got %q)\n' "${repo}" >&2
            exit 1
          fi
        fi

        # Optional allowlist guard (high value for internal platform safety)
        if [[ -n "${allowlist}" ]]; then
          allowed="0"
          while IFS= read -r line; do
            tool_trim="$(printf '%s' "${line}" | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')"
            [[ -z "${tool_trim}" ]] && continue
            [[ "${tool_trim}" == "#"* ]] && continue
            if [[ "${tool_trim}" == "${repo}" ]]; then
              allowed="1"
              break
            fi
          done <<< "${allowlist}"
          if [[ "${allowed}" != "1" ]]; then
            printf 'ERROR: repository %q not in allowed_repositories allowlist\n' "${repo}" >&2
            exit 1
          fi
        fi

        ref="${PS_REF_INPUT:-main}"
        if [[ -z "${ref}" ]]; then
          printf 'ERROR: inputs.ref must not be empty\n' >&2
          exit 1
        fi

        path="${PS_PATH_INPUT:-.ps-platform}"
        if [[ -z "${path}" ]]; then
          printf 'ERROR: inputs.path must not be empty\n' >&2
          exit 1
        fi
        # Path traversal guard (defense-in-depth): forbid absolute + any '..' segment.
        if [[ "${path}" == /* || "${path}" == *".."* ]]; then
          printf 'ERROR: inputs.path must be a repo-relative safe path (got %q)\n' "${path}" >&2
          exit 1
        fi

        depth="${PS_FETCH_DEPTH_INPUT:-1}"
        if ! [[ "${depth}" =~ ^[0-9]+$ ]]; then
          printf 'ERROR: inputs.fetch_depth must be a non-negative integer (got %q)\n' \
            "${depth}" >&2
          exit 1
        fi

        req="${PS_REQUIRE_FULL_HISTORY_INPUT:-false}"
        case "${req}" in true|false) ;; *)
          printf 'ERROR: inputs.require_full_history must be true|false (got %q)\n' "${req}" >&2
          exit 1 ;;
        esac
        if [[ "${req}" == "true" && "${depth}" != "0" ]]; then
          printf 'ERROR: full history required but fetch_depth=%s (expected 0)\n' "${depth}" >&2
          exit 1
        fi

        require_pinned="${PS_REQUIRE_PINNED_REF_INPUT:-false}"
        case "${require_pinned}" in true|false) ;; *)
          printf 'ERROR: inputs.require_pinned_ref must be true|false (got %q)\n' \
            "${require_pinned}" >&2
          exit 1 ;;
        esac

        pc="${PS_PERSIST_CREDENTIALS_INPUT:-false}"
        case "${pc}" in true|false) ;; *)
          printf 'ERROR: inputs.persist_credentials must be true|false (got %q)\n' \
            "${pc}" >&2
          exit 1 ;;
        esac

        sm="${PS_SUBMODULES_INPUT:-false}"
        case "${sm}" in false|true|recursive) ;; *)
          printf 'ERROR: inputs.submodules must be false|true|recursive (got %q)\n' "${sm}" >&2
          exit 1 ;;
        esac

        clean="${PS_CLEAN_PATH_INPUT:-false}"
        case "${clean}" in true|false) ;; *)
          printf 'ERROR: inputs.clean_path must be true|false (got %q)\n' "${clean}" >&2
          exit 1 ;;
        esac

        emit_env "PS_PLATFORM_REPO_VALIDATED" "${repo}"
        emit_env "PS_PLATFORM_REF_VALIDATED" "${ref}"
        emit_env "PS_PLATFORM_PATH_VALIDATED" "${path}"
        emit_env "PS_PLATFORM_FETCH_DEPTH_VALIDATED" "${depth}"
        emit_env "PS_PLATFORM_PERSIST_CREDENTIALS_VALIDATED" "${pc}"
        emit_env "PS_PLATFORM_SUBMODULES_VALIDATED" "${sm}"
        emit_env "PS_PLATFORM_REQUIRE_FULL_HISTORY_VALIDATED" "${req}"
        emit_env "PS_PLATFORM_CLEAN_PATH_VALIDATED" "${clean}"
        emit_env "PS_PLATFORM_REQUIRE_PINNED_REF_VALIDATED" "${require_pinned}"

        log_info "repository=${repo}"
        log_info "ref=${ref}"
        log_info "path=${path}"
        log_info "fetch_depth=${depth}"
        log_info "require_full_history=${req}"
        log_info "persist_credentials=${pc}"
        log_info "submodules=${sm}"
        log_info "clean_path=${clean}"
        log_info "require_pinned_ref=${require_pinned}"

    - name: Clean platform path (optional)
      if: ${{ env.PS_PLATFORM_CLEAN_PATH_VALIDATED == 'true' }}
      shell: bash
      run: |
        set -euo pipefail
        target="${GITHUB_WORKSPACE}/${PS_PLATFORM_PATH_VALIDATED}"
        if [[ -e "${target}" ]]; then
          printf 'PS.CHECKOUT.PLATFORM: cleaning %s\n' "${target}"
          rm -rf "${target}"
        fi

    - name: Checkout platform repository (PS)
      uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8
      with:
        repository: ${{ env.PS_PLATFORM_REPO_VALIDATED }}
        ref: ${{ env.PS_PLATFORM_REF_VALIDATED }}
        path: ${{ env.PS_PLATFORM_PATH_VALIDATED }}
        fetch-depth: ${{ env.PS_PLATFORM_FETCH_DEPTH_VALIDATED }}
        persist-credentials: ${{ env.PS_PLATFORM_PERSIST_CREDENTIALS_VALIDATED }}
        submodules: ${{ env.PS_PLATFORM_SUBMODULES_VALIDATED }}

    - name: Verify platform integrity (PS)
      shell: bash
      env:
        PS_PLATFORM_PATH: ${{ env.PS_PLATFORM_PATH_VALIDATED }}
        PS_PLATFORM_REF: ${{ env.PS_PLATFORM_REF_VALIDATED }}
        PS_PLATFORM_REQUIRE_PINNED_REF: >-
          ${{ env.PS_PLATFORM_REQUIRE_PINNED_REF_VALIDATED }}
      run: |
        set -euo pipefail

        platform_dir="${GITHUB_WORKSPACE}/${PS_PLATFORM_PATH}"
        if [[ ! -d "${platform_dir}" ]]; then
          printf 'ERROR: platform checkout path not found: %s\n' "${platform_dir}" >&2
          exit 1
        fi

        if ! git -C "${platform_dir}" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
          printf 'ERROR: platform checkout is not a git repository: %s\n' "${platform_dir}" >&2
          exit 1
        fi

        head_sha="$(git -C "${platform_dir}" rev-parse HEAD)"
        printf 'PS.CHECKOUT.PLATFORM: head_sha=%s\n' "${head_sha}"

        if [[ "${PS_PLATFORM_REQUIRE_PINNED_REF}" == "true" ]]; then
          if [[ ! "${PS_PLATFORM_REF}" =~ ^[0-9a-fA-F]{40}$ ]]; then
            printf 'ERROR: platform ref must be a full 40-char commit SHA when ' \
              'require_pinned_ref=true (got %s)\n' "${PS_PLATFORM_REF}" >&2
            exit 1
          fi
        fi

        if [[ "${PS_PLATFORM_REF}" =~ ^[0-9a-fA-F]{7,40}$ ]]; then
          expected_sha="$(git -C "${platform_dir}" rev-parse "${PS_PLATFORM_REF}^{commit}")"
          if [[ "${head_sha}" != "${expected_sha}" ]]; then
            printf 'ERROR: platform ref mismatch (expected %s, got %s)\n' \
              "${expected_sha}" "${head_sha}" >&2
            exit 1
          fi
        fi

        if [[ -n "$(git -C "${platform_dir}" status --porcelain)" ]]; then
          printf 'ERROR: platform checkout is not clean\n' >&2
          git -C "${platform_dir}" status --porcelain >&2
          exit 1
        fi

        missing="0"
        for rel in \
          "tools/scripts/branding/format.sh" \
          "tools/scripts/branding/print-section.sh" \
          "tools/scripts/branding/validate-inputs.sh" \
          "tools/scripts/ci/validate-ci/index.js" \
          "configs/ci/policies/validate-ci.yml"; do
          if [[ ! -f "${platform_dir}/${rel}" ]]; then
            printf 'ERROR: platform missing required file: %s\n' "${rel}" >&2
            missing="1"
          fi
        done

        if [[ "${missing}" == "1" ]]; then
          exit 1
        fi

        printf 'PS.CHECKOUT.PLATFORM: integrity=ok\n'

    - name: Emit outputs (PS)
      id: ps_checkout_platform_outputs
      shell: bash
      run: |
        set -euo pipefail
        {
          echo "platform_repository=${PS_PLATFORM_REPO_VALIDATED}"
          echo "platform_ref=${PS_PLATFORM_REF_VALIDATED}"
          echo "platform_path=${PS_PLATFORM_PATH_VALIDATED}"
          platform_path_abs="${GITHUB_WORKSPACE}/${PS_PLATFORM_PATH_VALIDATED}"
          echo "platform_path_abs=${platform_path_abs}"
        } >> "${GITHUB_OUTPUT}"

        printf 'PS.CHECKOUT.PLATFORM: OK\n'
